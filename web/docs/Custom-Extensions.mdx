---
sidebar_position: 60
title: Custom Extensions
---

import {GradleCode, AndroidCode} from "@theme/Code";

## Implementing an extension
Create a class extending one of the supported interfaces. 

It has to be `public` and have a zero-argument public constructor (as a result, it cannot be an inner class).

Example:

<AndroidCode>

```kotlin
class MyAdmin : ReportingAdministrator {
    init {
        Log.d("MyAdmin", "MyAdmin was loaded")
    }
}
```

```java
public MyAdmin implements ReportingAdministrator {
    public MyAdmin() {
        Log.d("MyAdmin", "MyAdmin was loaded");
    }
}
```

</AndroidCode>

| Supported Extensions | Use Case |
| --- | --- |
| [`Collector`](pathname:///javadoc/latest/acra/org.acra.collector/-collector) | Collect additional custom data not covered by acra |
| [`ApplicationStartupCollector`](pathname:///javadoc/latest/acra/org.acra.collector/-application-startup-collector) | Collector which is also called at startup |
| [`ReportInteraction`](pathname:///javadoc/latest/acra/org.acra.interaction/-report-interaction) | Usually not needed, as the provided options (dialog, notification, toast) cover all reasonable choices |
| [`ReportingAdministrator`](pathname:///javadoc/latest/acra/org.acra.config/-reporting-administrator) | Control when reports are generated and when the application should be stopped |
| [`ReportSenderFactory`](pathname:///javadoc/latest/acra/org.acra.sender/-report-sender-factory) | Register custom report senders |
| [`ConfigurationBuilderFactory`](pathname:///javadoc/latest/acra/org.acra.config/-configuration-builder-factory) | Register custom configurations |
| [`SenderSchedulerFactory`](pathname:///javadoc/latest/acra/org.acra.scheduler/-sender-scheduler-factory) | Register custom sender scheduler, e.g. to prevent report sending based on custom conditions |
| [`StartupProcessor`](pathname:///javadoc/latest/acra/org.acra.startup/-startup-processor)  | Do something ACRA related on app start |
## Registering an extension
Choose one of the following alternatives:
### By annotation

Add the following dependencies:
<GradleCode>

```kotlin title="build.gradle.kts"
compileOnly("com.google.auto.service:auto-service-annotations:1.1.1")
//either for java sources:
annotationProcessor("com.google.auto.service:auto-service:1.1.1")
//or for kotlin sources (requires kapt gradle plugin):
kapt("com.google.auto.service:auto-service:1.1.1")
//or for ksp(requires ksp gradle plugin):
ksp("dev.zacsweers.autoservice:auto-service-ksp:1.1.0")
ksp("com.google.auto.service:auto-service:1.1.1")
```

```groovy title="build.gradle"
compileOnly "com.google.auto.service:auto-service-annotations:1.1.1"
//either for java sources:
annotationProcessor "com.google.auto.service:auto-service:1.1.1"
//or for kotlin sources (requires kapt gradle plugin):
kapt "com.google.auto.service:auto-service:1.1.1"
//or for ksp(requires ksp gradle plugin):
ksp "dev.zacsweers.autoservice:auto-service-ksp:1.1.0"
ksp "com.google.auto.service:auto-service:1.1.1"
```

</GradleCode>

Then annotate your extension with the following:

<AndroidCode>

```kotlin
@AutoService(<ExtensionInterface>::class)
```

```java
@AutoService(<ExtensionInterface>.class)
```

</AndroidCode>

### By file

If you prefer not to use the `@AutoService` annotation or if you need more control over the registration process, you can manually register your extension using Java's `ServiceLoader` mechanism.

#### How it works

The `ServiceLoader` uses text files in the `META-INF/services/` directory to discover implementations at runtime. Each file is named after the fully qualified name of the service interface and contains the fully qualified names of implementing classes.

#### Step-by-step guide

1. **Create the META-INF/services directory**

   In your Android project, create the following directory structure in your module's source set:
   - For main source set: `src/main/resources/META-INF/services/`
   - For debug/release variants: `src/<variant>/resources/META-INF/services/`

2. **Create the service file**

   Inside the `META-INF/services/` directory, create a file named after the fully qualified interface name. For example:
   - For `ReportSenderFactory`: `org.acra.sender.ReportSenderFactory`
   - For `Collector`: `org.acra.collector.Collector`
   - For `ReportingAdministrator`: `org.acra.config.ReportingAdministrator`

3. **Add your implementation class**

   In the service file, add the fully qualified name of your implementation class. If you have multiple implementations, add each on a separate line.

   Example file `src/main/resources/META-INF/services/org.acra.sender.ReportSenderFactory`:
   ```
   com.example.myapp.MySenderFactory
   com.example.myapp.AnotherSenderFactory
   ```

4. **Ensure your implementation is valid**

   - The class must be `public`
   - The class must have a public zero-argument constructor
   - The class must implement the service interface

#### Complete example

Let's say you have a custom `ReportSenderFactory` implementation in package `com.example.myapp`:

<AndroidCode>

```kotlin
package com.example.myapp

import android.content.Context
import org.acra.config.CoreConfiguration
import org.acra.data.CrashReportData
import org.acra.sender.ReportSender
import org.acra.sender.ReportSenderFactory

class MySender : ReportSender {
    override fun send(context: Context, errorContent: CrashReportData) {
        // Your implementation
    }
}

class MySenderFactory : ReportSenderFactory {
    // Must have a no-arg constructor (implicit in Kotlin)
    
    override fun create(context: Context, config: CoreConfiguration): ReportSender {
        return MySender()
    }
}
```

```java
package com.example.myapp;

import android.content.Context;
import org.acra.config.CoreConfiguration;
import org.acra.data.CrashReportData;
import org.acra.sender.ReportSender;
import org.acra.sender.ReportSenderFactory;

public class MySender implements ReportSender {
    @Override
    public void send(Context context, CrashReportData errorContent) {
        // Your implementation
    }
}

public class MySenderFactory implements ReportSenderFactory {
    // Must have a public no-arg constructor
    public MySenderFactory() {
    }
    
    @Override
    public ReportSender create(Context context, CoreConfiguration config) {
        return new MySender();
    }
}
```

</AndroidCode>

Create the file `src/main/resources/META-INF/services/org.acra.sender.ReportSenderFactory` with this content:
```
com.example.myapp.MySenderFactory
```

#### Troubleshooting

If your custom extension is not being loaded:

1. **Verify file location**: Ensure the service file is in `src/main/resources/META-INF/services/` and not in `src/main/assets/` or other directories.

2. **Check file name**: The file name must exactly match the fully qualified interface name (e.g., `org.acra.sender.ReportSenderFactory`).

3. **Verify class name**: The content must contain the fully qualified class name of your implementation (e.g., `com.example.myapp.MySenderFactory`).

4. **Check packaging**: After building, verify that the service file is included in your APK under `META-INF/services/`.

5. **ProGuard/R8**: If using code minification, ensure your implementation class is not stripped. Add a ProGuard rule if necessary:
   ```
   -keep class com.example.myapp.MySenderFactory { *; }
   ```

6. **Enable debug logging**: Set `ACRA.DEV_LOGGING = true` before initializing ACRA to see which factories are being loaded.

For more details, see the official [ServiceLoader documentation](https://developer.android.com/reference/java/util/ServiceLoader.html).